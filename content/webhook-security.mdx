---
title: "Webhook Validation"
date: "2025-12-11"
description: "How HMAC signatures secure your revalidation endpoint"
---

Public webhooks are dangerous. Anyone who knows your URL could trigger expensive revalidations. HMAC signatures solve this.

## The Problem

Without authentication:

```tsx
// Insecure
export async function POST() {
  revalidatePath('/') // Anyone can trigger this
  return Response.json({ revalidated: true })
}
```

An attacker could spam your endpoint, causing:
- Excessive GitHub API calls
- Unnecessary revalidations
- Potential DoS

## HMAC Signatures

GitHub signs every webhook payload with your secret:

```
X-Hub-Signature-256: sha256=<hmac_hex>
```

The signature is:
```
HMAC-SHA256(secret, request_body)
```

## Validation Process

1. Read raw request body
2. Compute HMAC using your secret
3. Compare with GitHub's signature
4. Use timing-safe comparison (prevents timing attacks)

```tsx
const signature = request.headers.get('x-hub-signature-256')
const body = await request.text()
const hmac = crypto.createHmac('sha256', secret)
hmac.update(body)
const digest = `sha256=${hmac.digest('hex')}`

if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(digest))) {
  return Response.json({ error: 'Invalid signature' }, { status: 401 })
}
```

## Why timingSafeEqual?

Regular string comparison leaks timing information:

```tsx
if (signature === digest) // BAD: Timing attack vulnerable
```

Early exit when first character differs â†’ attacker can brute-force character by character by measuring response times.

`crypto.timingSafeEqual` compares every byte regardless of mismatches.

## Branch Filtering

Only revalidate for main branch:

```tsx
const payload = JSON.parse(body)
if (payload.ref !== 'refs/heads/main') {
  return Response.json({ message: 'Ignored non-main branch' })
}
```

Prevents revalidating on every feature branch push.
