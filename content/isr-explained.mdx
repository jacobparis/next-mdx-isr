---
title: "How ISR Works"
date: "2025-12-12"
description: "Understanding Incremental Static Regeneration in Next.js"
---

ISR (Incremental Static Regeneration) lets pages transition between dynamic and static at runtime.

## The Key Insight

With ISR, a page can:

- Start as dynamic (server-rendered on first request)
- Become static (cached after first render)
- Return to dynamic (when cache expires or is invalidated)
- Become static again (re-cached on next request)

This cycle happens automatically without deploys.

## Enabling ISR

Export `generateStaticParams` does two things

1. Enables ISR for the route
2. Returns a list of params that will be pre-compiled at build time.

Number 1 is good, because static routes get downloaded and cached for instant navigations. Number 2 is bad here, because now our build time scales linearly with the size of our content library. Since we are ALREADY listening to webhooks to invalidate certain post URLs the moment they're updated, it will always be up to date and we don't want anything regenerating on build.

So we need generateStaticParams to enable ISR, but we want it to return the minimum amount of data, which is one tag.

```tsx
export async function generateStaticParams() {
	const slug = await getFirstPostSlug()
	if (!slug) return []

	return [{ slug }]
}
```

Without `generateStaticParams`, the build output shows no cache times:

```
├ ◐ /post/[slug]
│ └ /post/[slug]
```

With `generateStaticParams`, pages can be cached:

```
├ ◐ /post/[slug]                                30d      1y
│ ├ /post/[slug]                                30d      1y
│ └ /post/architecture                          30d      1y
```

The above 30d TTL and 1y SWR time is the maximum, and that's what you get when you don't do `export const revalidate = 60` in the ISR route. Since we're revalidating manually by purging the tag, there's no need for a time based revalidation.

```tsx
import { revalidatePath } from "next/cache"
revalidatePath(`/post/${slug}`)
```
